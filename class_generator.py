# -*- coding: utf-8 -*-
"""
Created on Fri Sep 29 14:46:18 2017

@author: mry09

Data Generator for NetFLICS and NetFLICS-CR
"""

"""
How to use:

Create class instance by 
newDataGenerator = DataGenerator(pat_list)
    
    Parameters:
    pat_list is the list of patterns, of format :...
    The default parameter for data assumed:
    Image is of 128*128 in size
    256 time gates

A batch of data can be generated by 
newDataGenerator.generate(list_IDs)
    
    Parameters:
    list_IDs takes format of list[int,]

What the file looks like (sample_0.mat e.g.):
    {'cs_data': [], 'intensity_image':[], 'lifetime_image': []}

"""

import numpy as np
import h5py
from os import path

folder_data = 'example_train_data'

class DataGenerator(object):
    'Generates data for Keras'
    
    def __init__(self, pat_list, num_gate = 256, img_size = 128, batch_size = 10, shuffle = True):
        
        self.pat_list = pat_list    # List of pattern
        self.num_gate = num_gate    # Number of timegate
        self.img_size = img_size    # image is img_size * img_size
        self.batch_size = batch_size
        self.shuffle = shuffle
        
    def generate(self, list_IDs):
        
        while 1:
            # generate order
            indexes = self.__get_exploration_order(list_IDs)
            # generate batch
            imax = int(len(indexes)/self.batch_size)    # Total len(indexes) amount of data, using 10 data per batch, so max index is len(index)/batch_size
            for i in range(imax):
                # find list of IDs, len(list_IDs_tmp = batch_size)
                list_IDs_tmp = [list_IDs[k] for k in indexes[i*self.batch_size:(i+1)*self.batch_size]]  # This is the index in data for each batch
                # generate data
                X, y1, y2 = self.__data_generation(list_IDs_tmp)
                # output
                yield X, [y1,y2]
                # yield X, y1
            
    
    def __get_exploration_order(self, list_IDs):
        
        'Generate order of exploration'
        indexes = np.arange(len(list_IDs))  # Randomise samples for training and testing
        if self.shuffle == True:
            np.random.shuffle(indexes)
        return indexes
    
    def __data_generation(self, list_IDs_temp):
        
        # initialization for training data, intensity image, lifetime image
        num_pat = np.size(self.pat_list)
        X = np.empty((self.batch_size, self.num_gate, num_pat))                 # training data, size: 10 * 256 * 1600 (batch * time gates * compressed measurements)
        y1 = np.empty((self.batch_size, self.img_size, self.img_size, 1))       # intensity image, size 10 * 128 * 128 * 1
        y2 = np.empty((self.batch_size, self.img_size, self.img_size, 1))       # lifetime image, size 10 * 128 * 128 * 1
        
        # generate data
        for i, ID in enumerate(list_IDs_temp):  # Data format
            sample = 'sample_'+str(ID)+'.mat'   # sample_1.mat to sample_10.mat (batch size 10)
            fn_data = path.join(folder_data, sample)    
            f = h5py.File(fn_data, 'r')         # h5py reads from the .mat data
            cs_data = f['cs_data'].value        # cs_data contained in the sample_0.mat
            X[i,:,:] = cs_data[:,self.pat_list] # Training data in [batch, timegate, patterns], rearranged by the order of patterns
            y1[i,:,:,0] = np.transpose(f['intensity_image'].value)  # intensity image transposed (why?)
            y2[i,:,:,0] = np.transpose(f['lifetime_image'].value)   # lifetime image transposed (why?)
            f.close()
        
        return X, y1, y2
